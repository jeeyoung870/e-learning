[ HTTP vs WebSocket ]
Commonality: Both are protocols
- HTTP: Consists of request <-> response. Stateless (not real-time).
	Unable to remember the user after responding.
- WebSocket: If supported, can use 'wss' instead of 'http'.
	Browser <-connection-> Server (bi-directional), Or server <-> server is also possible! 
	Real-time communication possible upon connection establishment.
	Remembers the user.
	Can send information from the server without waiting for a request.
	Built-in WebSocket API can be used in the browser.



[ ws: WebSocket Library for nodeJS ]
- It can be used similarly to the addEventListener in HTML.
- Events are triggered, and the function to handle them is specified.
ex) back-end -> socket.on("connection", (socket)=>{});
    front-end -> socket.addEventListener("open", callback);

- Be aware of the order of execution:
When WebSocket connects > wss.on("connection", (socket)=>{}); is executed
                        socket.addEventListener("open", callback); is executed
server.js > socket.send("hello!");  is sent.
app.js > socket.addEventListener("message", callback);  is executed.
When disconnected > socket.addEventListener("message", callback);  is executed.

** When connecting to http://localhost:3000 from different browsers,
    the browsers are connected to a single server, but they are not connected to each other,
    so they cannot share messages sent by each other.
    To achieve that, declare const sockets = []; 
** In app.js, both handleSubmit() and handleNickSubmit() use socket.send().
    One sends a message and the other sends a nickname, but since the server receives both of them as "on("message",
    it's impossible to distinguish what's what.
    Therefore, when sending, the argument should be a stringified JSON object with 'type:payload' values.




[ SocketIO: WebSocket Framework ]
- SocketIO: Provides real-time, event-based communication using WebSocket.
	It operates normally even if the browser's WebSocket is not available (high reliability).
	Many features required for real-time communication are already built-in, making it convenient.
	When connected to a SocketIO server,
	http://localhost:3000/socket.io/socket.io.js
	You can access the upper link.
	Since the SocketIO feature is more extensive than the browser's WebSocket, SocketIO must also be installed on the browser (front).
	So add the script to the view file after the above URL port path 
		(script(src="/socket.io/socket.io.js"))

- Features/Advantages:
1. Unlike 'ws', you can specify the event name directly, and Objects can be passed. 
	+) emit() function -> Multiple objects can also be passed. Unlimited.
2. At the front(app.js), socket.emit() function's last argument can bind a callback function. (Optional, but must be placed at the very end.) If you call this callback function in the server.js on() method (done();), it will run on the front(app.js), not the back.
3. If the server-browser are disconnected, it instantly searches for another active io server, and if it fails, it generates an error in the browser. It will repeatedly attempt every few seconds, so if you 'run' the server, the error will stop.
4. Provides its own id (socket.id) and its own room. -> socket.rooms / socket.join("room_name");


- Available Features:
1. Joining a room: 
	socket.join("roomName"); / socket.join(["roomName1", "roomName2"]); for multiple participation.
2. Leaving a room: 
	socket.leave("roomName"); / socket.leave(["roomName1", "roomName2"]); 
3-1. Send message/message+event to "everyone else" in a room, send privately to 'other users'.
	socket.to("roomName"); / socket.to(["roomName1", "roomName2"]); 
	socket.to("roomName").emit("eventName", { some:"data" }); 
	socket.to( /*specificUserSocketID*/ ).emit("hey"); 
3-2. Send an event to all connected sockets on the server. 
	io.sockets.emit("event", {some:"data"});
4. Event executed when a user socket is disconnected (but still in the room): 
	"disconnecting"
5. Make all/specific socket in a certain room forcibly join another room (server.js): 
	io.in("room1").socketJoin(["room2", "room3"]); 
	io.in(theSocketId).socketJoin("room1");
6. 'socket.rooms' and 'io.sockets.adapter.rooms' are different. 
	socket.rooms: Returns a Set object of rooms that the connected user (browser) belongs to. 
	io.sockets.adapter.rooms: Returns all rooms (key) and their socket IDs in a Set object (value) connected to socketIO (map object). 
	io.sockets.adapter.sids: Returns all socket IDs (key) and (ID, room name Set) (value) connected to socketIO (map object). 
	** adapter.rooms holds public + private // adapter.sids holds private only. 
		rooms' key = all room IDs. 
		sids' key = all socket IDs (= all private room IDs). 
		The private room's ID, which the socket originally has, is equal to its socket ID.

*** Note that, in JavaScript, when forEach in a 'map' object, the argument order is (val, key).



[ Adapter ]
Connection diagram :
client1 - serverA(socket) - Mongo Adapter - MongoDB
client2 - serverB(socket) - Mongo Adapter - MongoDB
Adapter= Allows client1 and client2 connected to different servers to communicate by connecting to the DB.
	Essential for large-scale applications.
	If the Adapter and DB are not connected for use, the system operates using memory information, so client1 and client2 cannot communicate. 




[ Admin UI for SocketIO ]
Reference link: https://socket.io/docs/v4/admin-ui/
=> Admin UI panel for SocketIO backend. Allows viewing of all sockets, rooms, and users.
Installation required > npm i @socket.io/admin-ui
Allows individual or global socket joining/leaving of rooms.