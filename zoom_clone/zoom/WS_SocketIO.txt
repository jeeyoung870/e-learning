[ HTTP vs WebSocket ]
공통점 : 둘다 protocol임
- HTTP : request <-> response 로 이루어짐.
    stateless(실시간이 아님.)
    respond 후에 user를 기억하지 못함.
- WebSocket : 지원만 된다면 http대신 wss 사용가능
    브라우저 <-connection-> 서버 (bi-directional)
    혹은 서버 <-> 서버도 가능!
    connection 성립시 real-time communication 가능
    user 기억함
    요청 기다리지 않고 서버에서 정보 송신 가능
    브라우저 내장 WebSocket API 사용가능

[ ws : WebSocket Library for nodeJS ]
html의 addEventListener 처럼 비슷하게 사용할 수 있다.
event가 발생하고, 처리할 함수를 지정함.
ex) back의 경우 : socket.on("connection", (socket)=>{});
    front의 경우 : socket.addEventListener("open", callback);

동작순서에 유의한다 : 
웹소켓 연결시> wss.on("connection", (socket)=>{}); 실행
            socket.addEventListener("open", callback); 실행
server.js> socket.send("hello!"); 전송
app.js> socket.addEventListener("message", callback); 실행
연결 해제시> socket.addEventListener("message", callback); 실행

** 각각 다른 브라우저에서 http://localhost:3000에 접속할경우,
    브라우저들은 한 서버와 연결되지만, 브라우저끼리는 연결되지 않아서 
    각각이 보낸 메세지를 공유할 수 없다.
    이를 위해 const sockets = []; 을 선언해줌

** app.js 에서 handleSubmit()과 handleNickSubmit()에서는 둘다 socket.send()를 사용한다.
    하나는 메시지고 하나는 닉네임을 전송하지만 서버에서는 이 둘을 모두 on("message" 로 받기 때문에
    뭐가 뭔지 구별해낼 수 없다.
    그러므로 send시의 인자는 type:payload 값을 가지는 json객체를 stringify 한것을 넣는다.


[ SocketIO : WebSocket Framework ]
- SocketIO : WebSocket을 '사용'하는 real-time, event기반 소통을 제공함
        브라우저의 WebSocket사용이 불가해도 정상가동함(신뢰도높음)
        실시간 통신에 필요한 여러 기능들이 이미 만들어져 있어 편리함.
SocketIO 서버에 연결하면
http://localhost:3000/socket.io/socket.io.js
링크에 접속 가능해진다.
브라우저의 WebSocket보다 SocketIO 기능이 더 많기 때문에 브라우저(front)에도 SocketIO를 설치해야 한다.
그러므로 위 url 포트이후경로를 view파일에 script 추가해줌 ( script(src="/socket.io/socket.io.js") )

- 특징/장점 : 
    1. ws와 달리 event명을 직접지정 가능하고, Object객체를 전달할 수 있다. emit() 함수
        전달 객체도 여러 개가 가능하다. 무제한.
    2. front(app.js) 의 socket.emit()함수의 마지막 인자로 콜백함수를 바인딩할 수 있다. 
        (Optional 이지만 꼭 마지막에 넣어야 함.)
        이 콜백함수를 server.js의 on메소드에서 호출하면(done();), 이는 백이 아닌 프론트(app.js)에서 실행된다.
    3. 서버-브라우저 연결이 끊기면 즉시 가동중인 다른 io서버를 찾고, 실패시 브라우저상에 error를 발생시킨다.
        몇초 간격으로 계속 시도하기 때문에 서버run 해주면 error가 멈춘다.
    4. 자체id(socket.id), 자체 room을 제공함. socket.rooms / socket.join("방이름");

- 기능 : 
1. 방 입장
    socket.join("방이름"); / socket.join(["방이름1", "방이름2"]); 복수참여
2. 방 퇴장
    socket.leave("방이름"); / socket.leave(["방이름1", "방이름2"]);
3-1. 나 이외의 방'전체'에 메시지/메시지+event 보내기, '다른사용자'에게 private으로 보내기
    socket.to("방이름"); / socket.to(["방이름1", "방이름2"]);
    socket.to("방이름").emit("eventName", { some:"data" });
    socket.to( /*특정사용자소켓id*/ ).emit("hey");
3-2. 서버에 연결된 모든 소켓에게 event 전송하기
    io.sockets.emit("event", {some:"data"});
4. 사용자소켓 연결 해제시(그러나 아직 방에 있는상태) 실행되는 event
    "disconnecting"
5. 특정 방 모든소켓/특정소켓 을 강제로 다른 방에 참여하게 만들기 (server.js에서 가능)
    io.in("room1").socketJoin(["room2", "room3"]);
    io.in(theSocketId).socketJoin("room1");
6. socket.rooms와 io.sockets.adapter.rooms 는 다름.
    socket.rooms : 현재 접속한 사용자(브라우저)가 속한 방 리턴(Set객체)
    io.sockets.adapter.rooms : socketIO에 연결된 모든 방(key)과 거기 속한 id집합인 Set객체(value)를 리턴.(map객체)
    io.sockets.adapter.sids : socketIO에 연결된 모든 id(key), (id,방이름 Set)(value)를 리턴 (map객체)
    ** adapter.rooms 는 public + priate // adapter.sids 는 private only
        rooms의 key = 모든 room id
        sids의 key = 모든 socket id (= 모든 private room id)
        원래부터 소켓이 가지고 있는 private방의 id는 해당소켓의 id와 같음.

*** javascript는 map객체 forEach 시 인자 순서가 (val, key) 임. 왜 그런지?모르겠음 짜증나게..

[ Adapter ]
연결도식 :
client1 - serverA(socket) - Mongo Adapter - MongoDB
client2 - serverB(socket) - Mongo Adapter - MongoDB
Adapter= 다른 서버에 연결된 client1과 client2도  소통할 수 있게 DB와 연결하는 역할
    큰 규모의 application에는 필수적.
    Adapter와 DB를 연결해 사용하지 않으면 메모리정보로 동작하기 때문에 client1과 client2는 통신할수 없다.

[ Admin UI for SocketIO ]
참고링크 : https://socket.io/docs/v4/admin-ui/
=> SocketIO 백엔드를 위한 관리자 UI패널. 모든 sockets,rooms,user 확인 가능
설치 필요 > npm i @socket.io/admin-ui
개별/전체 소켓 방참여/퇴장 가능
