[ HTTP vs WebSocket ]
공통점 : 둘다 protocol임
- HTTP : request <-> response 로 이루어짐.
    stateless(실시간이 아님.)
    respond 후에 user를 기억하지 못함.
- WebSocket : 지원만 된다면 http대신 wss 사용가능
    브라우저 <-connection-> 서버 (bi-directional)
    혹은 서버 <-> 서버도 가능!
    connection 성립시 real-time communication 가능
    user 기억함
    요청 기다리지 않고 서버에서 정보 송신 가능
    브라우저 내장 WebSocket API 사용가능

[ ws : WebSocket Library for nodeJS ]
html의 addEventListener 처럼 비슷하게 사용할 수 있다.
event가 발생하고, 처리할 함수를 지정함.
ex) back의 경우 : socket.on("connection", (socket)=>{});
    front의 경우 : socket.addEventListener("open", callback);

동작순서에 유의한다 : 
웹소켓 연결시> wss.on("connection", (socket)=>{}); 실행
            socket.addEventListener("open", callback); 실행
server.js> socket.send("hello!"); 전송
app.js> socket.addEventListener("message", callback); 실행
연결 해제시> socket.addEventListener("message", callback); 실행

** 각각 다른 브라우저에서 http://localhost:3000에 접속할경우,
    브라우저들은 한 서버와 연결되지만, 브라우저끼리는 연결되지 않아서 
    각각이 보낸 메세지를 공유할 수 없다.
    이를 위해 const sockets = []; 을 선언해줌

** app.js 에서 handleSubmit()과 handleNickSubmit()에서는 둘다 socket.send()를 사용한다.
    하나는 메시지고 하나는 닉네임을 전송하지만 서버에서는 이 둘을 모두 on("message" 로 받기 때문에
    뭐가 뭔지 구별해낼 수 없다.
    그러므로 send시의 인자는 type:payload 값을 가지는 json객체를 stringify 한것을 넣는다.


[ SocketIO : WebSocket Framework ]
- SocketIO : WebSocket을 '사용'하는 real-time, event기반 소통을 제공함
        브라우저의 WebSocket사용이 불가해도 정상가동함(신뢰도높음)
        실시간 통신에 필요한 여러 기능들이 이미 만들어져 있어 편리함.
SocketIO 서버에 연결하면
http://localhost:3000/socket.io/socket.io.js
링크에 접속 가능해진다.
브라우저의 WebSocket보다 SocketIO 기능이 더 많기 때문에 브라우저(front)에도 SocketIO를 설치해야 한다.
그러므로 위 url 포트이후경로를 view파일에 script 추가해줌 ( script(src="/socket.io/socket.io.js") )

- 특징/장점 : 
    1. ws와 달리 event명을 직접지정 가능하고, Object객체를 전달할 수 있다. emit() 함수
        전달 객체도 여러 개가 가능하다. 무제한.
    2. front(app.js) 의 socket.emit()함수의 마지막 인자로 콜백함수를 바인딩할 수 있다. 
        (Optional 이지만 꼭 마지막에 넣어야 함.)
        이 콜백함수를 server.js의 on메소드에서 호출하면(done();), 이는 백이 아닌 프론트(app.js)에서 실행된다.
    3. 서버-브라우저 연결이 끊기면 즉시 가동중인 다른 io서버를 찾고, 실패시 브라우저상에 error를 발생시킨다.
        몇초 간격으로 계속 시도하기 때문에 서버run 해주면 error가 멈춘다.
    4. 자체id(socket.id), 자체 room을 제공함. socket.rooms / socket.join("방이름");

- 기능 : 
1. 방 입장
    socket.join("방이름"); / socket.join(["방이름1", "방이름2"]); 복수참여
2. 방 퇴장
    socket.leave("방이름"); / socket.leave(["방이름1", "방이름2"]);
3. 방전체에 메시지/메시지+event 보내기
    socket.to("방이름"); / socket.to(["방이름1", "방이름2"]);
    socket.to("방이름").emit("eventName", { some:"data" });
